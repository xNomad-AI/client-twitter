{"version":3,"sources":["../src/index.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/search.ts","../src/spaces.ts","../src/plugins/SttTtsSpacesPlugin.ts"],"sourcesContent":["import { Client, elizaLogger, IAgentRuntime } from \"@elizaos/core\";\nimport { ClientBase } from \"./base.ts\";\nimport { validateTwitterConfig, TwitterConfig } from \"./environment.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { TwitterPostClient } from \"./post.ts\";\nimport { TwitterSearchClient } from \"./search.ts\";\nimport { TwitterSpaceClient } from \"./spaces.ts\";\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\nclass TwitterManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    search: TwitterSearchClient;\n    interaction: TwitterInteractionClient;\n    space?: TwitterSpaceClient;\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        // Pass twitterConfig to the base client\n        this.client = new ClientBase(runtime, twitterConfig);\n\n        // Posting logic\n        this.post = new TwitterPostClient(this.client, runtime);\n\n        // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\n        if (twitterConfig.TWITTER_SEARCH_ENABLE) {\n            elizaLogger.warn(\"Twitter/X client running in a mode that:\");\n            elizaLogger.warn(\"1. violates consent of random users\");\n            elizaLogger.warn(\"2. burns your rate limit\");\n            elizaLogger.warn(\"3. can get your account banned\");\n            elizaLogger.warn(\"use at your own risk\");\n            this.search = new TwitterSearchClient(this.client, runtime);\n        }\n\n        // Mentions and interactions\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n\n        // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n        if (twitterConfig.TWITTER_SPACES_ENABLE) {\n            this.space = new TwitterSpaceClient(this.client, runtime);\n        }\n    }\n}\n\nexport const TwitterClientInterface: Client = {\n    async start(runtime: IAgentRuntime) {\n        const twitterConfig: TwitterConfig =\n            await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        const manager = new TwitterManager(runtime, twitterConfig);\n\n        // Initialize login/session\n        await manager.client.init();\n\n        // Start the posting loop\n        await manager.post.start();\n\n        // Start the search logic if it exists\n        if (manager.search) {\n            await manager.search.start();\n        }\n\n        // Start interactions (mentions, replies)\n        await manager.interaction.start();\n\n        // If Spaces are enabled, start the periodic check\n        if (manager.space) {\n            manager.space.startPeriodicSpaceCheck();\n        }\n\n        return manager;\n    },\n\n    async stop(_runtime: IAgentRuntime) {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    },\n};\n\nexport default TwitterClientInterface;\n","import {\n    Content,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    State,\n    UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n    ActionTimelineType,\n} from \"@elizaos/core\";\nimport {\n    QueryTweetsResponse,\n    Scraper,\n    SearchMode,\n    Tweet,\n} from \"agent-twitter-client\";\nimport { EventEmitter } from \"events\";\nimport { TwitterConfig } from \"./environment.ts\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n    id: string;\n    username: string;\n    screenName: string;\n    bio: string;\n    nicknames: string[];\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing: boolean = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n    twitterClient: Scraper;\n    runtime: IAgentRuntime;\n    twitterConfig: TwitterConfig;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature: number = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: Tweet): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n        const cached = await this.runtime.cacheManager.get<Tweet>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<Tweet> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        const tweet = await this.requestQueue.add(() =>\n            this.twitterClient.getTweet(tweetId)\n        );\n\n        await this.cacheTweet(tweet);\n        return tweet;\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        super();\n        this.runtime = runtime;\n        this.twitterConfig = twitterConfig;\n        const username = twitterConfig.TWITTER_USERNAME;\n        if (ClientBase._twitterClients[username]) {\n            this.twitterClient = ClientBase._twitterClients[username];\n        } else {\n            this.twitterClient = new Scraper();\n            ClientBase._twitterClients[username] = this.twitterClient;\n        }\n\n        this.directions =\n            \"- \" +\n            this.runtime.character.style.all.join(\"\\n- \") +\n            \"- \" +\n            this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        const username = this.twitterConfig.TWITTER_USERNAME;\n        const password = this.twitterConfig.TWITTER_PASSWORD;\n        const email = this.twitterConfig.TWITTER_EMAIL;\n        let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;\n        const twitter2faSecret = this.twitterConfig.TWITTER_2FA_SECRET;\n\n        if (!username) {\n            throw new Error(\"Twitter username not configured\");\n        }\n\n        const cachedCookies = await this.getCachedCookies(username);\n\n        if (cachedCookies) {\n            elizaLogger.info(\"Using cached cookies\");\n            await this.setCookiesFromArray(cachedCookies);\n        }\n\n        elizaLogger.log(\"Waiting for Twitter login\");\n        while (retries > 0) {\n            try {\n                if (await this.twitterClient.isLoggedIn()) {\n                    // cookies are valid, no login required\n                    elizaLogger.info(\"Successfully logged in.\");\n                    break;\n                } else {\n                    await this.twitterClient.login(\n                        username,\n                        password,\n                        email,\n                        twitter2faSecret\n                    );\n                    if (await this.twitterClient.isLoggedIn()) {\n                        // fresh login, store new cookies\n                        elizaLogger.info(\"Successfully logged in.\");\n                        elizaLogger.info(\"Caching cookies\");\n                        await this.cacheCookies(\n                            username,\n                            await this.twitterClient.getCookies()\n                        );\n                        break;\n                    }\n                }\n            } catch (error) {\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\n            }\n\n            retries--;\n            elizaLogger.error(\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\n            );\n\n            if (retries === 0) {\n                elizaLogger.error(\n                    \"Max retries reached. Exiting login process.\"\n                );\n                throw new Error(\"Twitter login failed after maximum retries.\");\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n        }\n        // Initialize Twitter profile\n        this.profile = await this.fetchProfile(username);\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                screenName: this.profile.screenName,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n\n        await this.loadLatestCheckedTweetId();\n        await this.populateTimeline();\n    }\n\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        const homeTimeline = await this.twitterClient.getUserTweets(\n            this.profile.id,\n            count\n        );\n        return homeTimeline.tweets;\n    }\n\n    /**\n     * Fetch timeline for twitter account, optionally only from followed accounts\n     */\n    async fetchHomeTimeline(\n        count: number,\n        following?: boolean\n    ): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        const homeTimeline = following\n            ? await this.twitterClient.fetchFollowingTimeline(count, [])\n            : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        elizaLogger.debug(homeTimeline, { depth: Infinity });\n        const processedTimeline = homeTimeline\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n            .map((tweet) => {\n                //console.log(\"tweet is\", tweet);\n                const obj = {\n                    id: tweet.id,\n                    name:\n                        tweet.name ?? tweet?.user_results?.result?.legacy.name,\n                    username:\n                        tweet.username ??\n                        tweet.core?.user_results?.result?.legacy.screen_name,\n                    text: tweet.text ?? tweet.legacy?.full_text,\n                    inReplyToStatusId:\n                        tweet.inReplyToStatusId ??\n                        tweet.legacy?.in_reply_to_status_id_str ??\n                        null,\n                    timestamp:\n                        new Date(tweet.legacy?.created_at).getTime() / 1000,\n                    createdAt:\n                        tweet.createdAt ??\n                        tweet.legacy?.created_at ??\n                        tweet.core?.user_results?.result?.legacy.created_at,\n                    userId: tweet.userId ?? tweet.legacy?.user_id_str,\n                    conversationId:\n                        tweet.conversationId ??\n                        tweet.legacy?.conversation_id_str,\n                    permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n                    hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\n                    mentions:\n                        tweet.mentions ?? tweet.legacy?.entities.user_mentions,\n                    photos:\n                        tweet.legacy?.entities?.media\n                            ?.filter((media) => media.type === \"photo\")\n                            .map((media) => ({\n                                id: media.id_str,\n                                url: media.media_url_https, // Store media_url_https as url\n                                alt_text: media.alt_text,\n                            })) || [],\n                    thread: tweet.thread || [],\n                    urls: tweet.urls ?? tweet.legacy?.entities.urls,\n                    videos:\n                        tweet.videos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"video\"\n                        ) ??\n                        [],\n                };\n                //console.log(\"obj is\", obj);\n                return obj;\n            });\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        return processedTimeline;\n    }\n\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n\n        const agentUsername = this.twitterConfig.TWITTER_USERNAME;\n\n        const homeTimeline =\n            this.twitterConfig.ACTION_TIMELINE_TYPE ===\n            ActionTimelineType.Following\n                ? await this.twitterClient.fetchFollowingTimeline(count, [])\n                : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        return homeTimeline\n            .map((tweet) => ({\n                id: tweet.rest_id,\n                name: tweet.core?.user_results?.result?.legacy?.name,\n                username: tweet.core?.user_results?.result?.legacy?.screen_name,\n                text: tweet.legacy?.full_text,\n                inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,\n                timestamp: new Date(tweet.legacy?.created_at).getTime() / 1000,\n                userId: tweet.legacy?.user_id_str,\n                conversationId: tweet.legacy?.conversation_id_str,\n                permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n                hashtags: tweet.legacy?.entities?.hashtags || [],\n                mentions: tweet.legacy?.entities?.user_mentions || [],\n                photos:\n                    tweet.legacy?.entities?.media\n                        ?.filter((media) => media.type === \"photo\")\n                        .map((media) => ({\n                            id: media.id_str,\n                            url: media.media_url_https, // Store media_url_https as url\n                            alt_text: media.alt_text,\n                        })) || [],\n                thread: tweet.thread || [],\n                urls: tweet.legacy?.entities?.urls || [],\n                videos:\n                    tweet.legacy?.entities?.media?.filter(\n                        (media) => media.type === \"video\"\n                    ) || [],\n            }))\n            .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\n            .slice(0, count);\n        // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\n        // this workaround can be removed.\n        // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 15000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    async () =>\n                        await Promise.race([\n                            this.twitterClient.fetchSearchTweets(\n                                query,\n                                maxTweets,\n                                searchMode,\n                                cursor\n                            ),\n                            timeoutPromise,\n                        ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.screenName,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.twitterConfig.TWITTER_USERNAME;\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.screenName,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\n        return await this.runtime.cacheManager.get<Tweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async fetchProfile(username: string): Promise<TwitterProfile> {\n        try {\n            const profile = await this.requestQueue.add(async () => {\n                const profile = await this.twitterClient.getProfile(username);\n                return {\n                    id: profile.userId,\n                    username,\n                    screenName: profile.name || this.runtime.character.name,\n                    bio:\n                        profile.biography ||\n                        typeof this.runtime.character.bio === \"string\"\n                            ? (this.runtime.character.bio as string)\n                            : this.runtime.character.bio.length > 0\n                              ? this.runtime.character.bio[0]\n                              : \"\",\n                    nicknames:\n                        this.runtime.character.twitterProfile?.nicknames || [],\n                } satisfies TwitterProfile;\n            });\n\n            return profile;\n        } catch (error) {\n            console.error(\"Error fetching Twitter profile:\", error);\n            throw error;\n        }\n    }\n}\n","import {\n    parseBooleanFromText,\n    IAgentRuntime,\n    ActionTimelineType,\n} from \"@elizaos/core\";\nimport { z, ZodError } from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nconst twitterUsernameSchema = z\n    .string()\n    .min(1, \"An X/Twitter Username must be at least 1 character long\")\n    .max(15, \"An X/Twitter Username cannot exceed 15 characters\")\n    .refine((username) => {\n        // Allow wildcard '*' as a special case\n        if (username === \"*\") return true;\n\n        // Twitter usernames can:\n        // - Start with digits now\n        // - Contain letters, numbers, underscores\n        // - Must not be empty\n        return /^[A-Za-z0-9_]+$/.test(username);\n    }, \"An X Username can only contain letters, numbers, and underscores\");\n\n/**\n * This schema defines all required/optional environment settings,\n * including new fields like TWITTER_SPACES_ENABLE.\n */\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z.boolean(),\n    TWITTER_USERNAME: z.string().min(1, \"X/Twitter username is required\"),\n    TWITTER_PASSWORD: z.string().min(1, \"X/Twitter password is required\"),\n    TWITTER_EMAIL: z.string().email(\"Valid X/Twitter email is required\"),\n    MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\n    TWITTER_SEARCH_ENABLE: z.boolean().default(false),\n    TWITTER_2FA_SECRET: z.string(),\n    TWITTER_RETRY_LIMIT: z.number().int(),\n    TWITTER_POLL_INTERVAL: z.number().int(),\n    TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\n    // I guess it's possible to do the transformation with zod\n    // not sure it's preferable, maybe a readability issue\n    // since more people will know js/ts than zod\n    /*\n        z\n        .string()\n        .transform((val) => val.trim())\n        .pipe(\n            z.string()\n                .transform((val) =>\n                    val ? val.split(',').map((u) => u.trim()).filter(Boolean) : []\n                )\n                .pipe(\n                    z.array(\n                        z.string()\n                            .min(1)\n                            .max(15)\n                            .regex(\n                                /^[A-Za-z][A-Za-z0-9_]*[A-Za-z0-9]$|^[A-Za-z]$/,\n                                'Invalid Twitter username format'\n                            )\n                    )\n                )\n                .transform((users) => users.join(','))\n        )\n        .optional()\n        .default(''),\n    */\n    POST_INTERVAL_MIN: z.number().int(),\n    POST_INTERVAL_MAX: z.number().int(),\n    ENABLE_ACTION_PROCESSING: z.boolean(),\n    ACTION_INTERVAL: z.number().int(),\n    POST_IMMEDIATELY: z.boolean(),\n    TWITTER_SPACES_ENABLE: z.boolean().default(false),\n    MAX_ACTIONS_PROCESSING: z.number().int(),\n    ACTION_TIMELINE_TYPE: z\n        .nativeEnum(ActionTimelineType)\n        .default(ActionTimelineType.ForYou),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\n/**\n * Helper to parse a comma-separated list of Twitter usernames\n * (already present in your code).\n */\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\n    if (!targetUsersStr?.trim()) {\n        return [];\n    }\n    return targetUsersStr\n        .split(\",\")\n        .map((user) => user.trim())\n        .filter(Boolean);\n}\n\nfunction safeParseInt(\n    value: string | undefined | null,\n    defaultValue: number\n): number {\n    if (!value) return defaultValue;\n    const parsed = parseInt(value, 10);\n    return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\n}\n\n/**\n * Validates or constructs a TwitterConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\n// This also is organized to serve as a point of documentation for the client\n// most of the inputs from the framework (env/character)\n\n// we also do a lot of typing/parsing here\n// so we can do it once and only once per character\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                        process.env.TWITTER_DRY_RUN\n                ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\n\n            TWITTER_USERNAME:\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\n                process.env.TWITTER_USERNAME,\n\n            TWITTER_PASSWORD:\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\n                process.env.TWITTER_PASSWORD,\n\n            TWITTER_EMAIL:\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\n                process.env.TWITTER_EMAIL,\n\n            // number as string?\n            MAX_TWEET_LENGTH: safeParseInt(\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                    process.env.MAX_TWEET_LENGTH,\n                DEFAULT_MAX_TWEET_LENGTH\n            ),\n\n            TWITTER_SEARCH_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SEARCH_ENABLE\") ||\n                        process.env.TWITTER_SEARCH_ENABLE\n                ) ?? false,\n\n            // string passthru\n            TWITTER_2FA_SECRET:\n                runtime.getSetting(\"TWITTER_2FA_SECRET\") ||\n                process.env.TWITTER_2FA_SECRET ||\n                \"\",\n\n            // int\n            TWITTER_RETRY_LIMIT: safeParseInt(\n                runtime.getSetting(\"TWITTER_RETRY_LIMIT\") ||\n                    process.env.TWITTER_RETRY_LIMIT,\n                5\n            ),\n\n            // int in seconds\n            TWITTER_POLL_INTERVAL: safeParseInt(\n                runtime.getSetting(\"TWITTER_POLL_INTERVAL\") ||\n                    process.env.TWITTER_POLL_INTERVAL,\n                120 // 2m\n            ),\n\n            // comma separated string\n            TWITTER_TARGET_USERS: parseTargetUsers(\n                runtime.getSetting(\"TWITTER_TARGET_USERS\") ||\n                    process.env.TWITTER_TARGET_USERS\n            ),\n\n            // int in minutes\n            POST_INTERVAL_MIN: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MIN\") ||\n                    process.env.POST_INTERVAL_MIN,\n                90 // 1.5 hours\n            ),\n\n            // int in minutes\n            POST_INTERVAL_MAX: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MAX\") ||\n                    process.env.POST_INTERVAL_MAX,\n                180 // 3 hours\n            ),\n\n            // bool\n            ENABLE_ACTION_PROCESSING:\n                parseBooleanFromText(\n                    runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ||\n                        process.env.ENABLE_ACTION_PROCESSING\n                ) ?? false,\n\n            // init in minutes (min 1m)\n            ACTION_INTERVAL: safeParseInt(\n                runtime.getSetting(\"ACTION_INTERVAL\") ||\n                    process.env.ACTION_INTERVAL,\n                5 // 5 minutes\n            ),\n\n            // bool\n            POST_IMMEDIATELY:\n                parseBooleanFromText(\n                    runtime.getSetting(\"POST_IMMEDIATELY\") ||\n                        process.env.POST_IMMEDIATELY\n                ) ?? false,\n\n            TWITTER_SPACES_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SPACES_ENABLE\") ||\n                        process.env.TWITTER_SPACES_ENABLE\n                ) ?? false,\n\n            MAX_ACTIONS_PROCESSING: safeParseInt(\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\n                    process.env.MAX_ACTIONS_PROCESSING,\n                1\n            ),\n\n            ACTION_TIMELINE_TYPE:\n                runtime.getSetting(\"ACTION_TIMELINE_TYPE\") ||\n                process.env.ACTION_TIMELINE_TYPE,\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `X/Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n    IImageDescriptionService,\n    ServiceType\n} from \"@elizaos/core\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\n\nCurrent Post:\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\n\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\nIMPORTANT:\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\nRecent Posts:\n{{recentPosts}}\n\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    private isDryRun: boolean;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                // Defaults to 2 minutes\n                this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n\n        const twitterUsername = this.client.profile.username;\n        try {\n            // Check for mentions\n            const mentionCandidates = (\n                await this.client.fetchSearchTweets(\n                    `@${twitterUsername}`,\n                    20,\n                    SearchMode.Latest\n                )\n            ).tweets;\n\n            elizaLogger.log(\n                \"Completed checking mentioned tweets:\",\n                mentionCandidates.length\n            );\n            let uniqueTweetCandidates = [...mentionCandidates];\n            // Only process target users if configured\n            if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {\n                const TARGET_USERS =\n                    this.client.twitterConfig.TWITTER_TARGET_USERS;\n\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\n\n                if (TARGET_USERS.length > 0) {\n                    // Create a map to store tweets by user\n                    const tweetsByUser = new Map<string, Tweet[]>();\n\n                    // Fetch tweets from all target users\n                    for (const username of TARGET_USERS) {\n                        try {\n                            const userTweets = (\n                                await this.client.twitterClient.fetchSearchTweets(\n                                    `from:${username}`,\n                                    3,\n                                    SearchMode.Latest\n                                )\n                            ).tweets;\n\n                            // Filter for unprocessed, non-reply, recent tweets\n                            const validTweets = userTweets.filter((tweet) => {\n                                const isUnprocessed =\n                                    !this.client.lastCheckedTweetId ||\n                                    parseInt(tweet.id) >\n                                        this.client.lastCheckedTweetId;\n                                const isRecent =\n                                    Date.now() - tweet.timestamp * 1000 <\n                                    2 * 60 * 60 * 1000;\n\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                                    isUnprocessed,\n                                    isRecent,\n                                    isReply: tweet.isReply,\n                                    isRetweet: tweet.isRetweet,\n                                });\n\n                                return (\n                                    isUnprocessed &&\n                                    !tweet.isReply &&\n                                    !tweet.isRetweet &&\n                                    isRecent\n                                );\n                            });\n\n                            if (validTweets.length > 0) {\n                                tweetsByUser.set(username, validTweets);\n                                elizaLogger.log(\n                                    `Found ${validTweets.length} valid tweets from ${username}`\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error fetching tweets for ${username}:`,\n                                error\n                            );\n                            continue;\n                        }\n                    }\n\n                    // Select one tweet from each user that has tweets\n                    const selectedTweets: Tweet[] = [];\n                    for (const [username, tweets] of tweetsByUser) {\n                        if (tweets.length > 0) {\n                            // Randomly select one tweet from this user\n                            const randomTweet =\n                                tweets[\n                                    Math.floor(Math.random() * tweets.length)\n                                ];\n                            selectedTweets.push(randomTweet);\n                            elizaLogger.log(\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n                            );\n                        }\n                    }\n\n                    // Add selected tweets to candidates\n                    uniqueTweetCandidates = [\n                        ...mentionCandidates,\n                        ...selectedTweets,\n                    ];\n                }\n            } else {\n                elizaLogger.log(\n                    \"No target users configured, processing only mentions\"\n                );\n            }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(\n                        tweet.id + \"-\" + this.runtime.agentId\n                    );\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userIdUUID =\n                        tweet.userId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { text: tweet.text },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: Tweet;\n        message: Memory;\n        thread: Tweet[];\n    }) {\n        if (tweet.userId === this.client.profile.id) {\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\n            // Skip processing if the tweet is from the bot itself\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: Tweet) => {\n            return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        elizaLogger.debug(\"Thread: \", thread);\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.username} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n        ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\n\n        const imageDescriptionsArray = [];\n        try{\n            elizaLogger.debug('Getting images');\n            for (const photo of tweet.photos) {\n                elizaLogger.debug(photo.url);\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptionsArray.push(description);\n            }\n        } catch (error) {\n    // Handle the error\n    elizaLogger.error(\"Error Occured during describing image: \", error);\n}\n\n\n\n\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,\n            currentPost,\n            formattedConversation,\n            imageDescriptions: imageDescriptionsArray.length > 0\n            ? `\\nImages in Tweet:\\n${imageDescriptionsArray.map((desc, i) =>\n              `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`).join(\"\\n\\n\")}`:\"\"\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.userId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // get usernames into str\n        const validTargetUsersStr =\n            this.client.twitterConfig.TWITTER_TARGET_USERS.join(\",\");\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`\n                );\n            } else {\n                try {\n                    const callback: HandlerCallback = async (\n                        response: Content\n                    ) => {\n                        const memories = await sendTweet(\n                            this.client,\n                            response,\n                            message.roomId,\n                            this.client.twitterConfig.TWITTER_USERNAME,\n                            tweet.id\n                        );\n                        return memories;\n                    };\n\n                    const responseMessages = await callback(response);\n\n                    state = (await this.runtime.updateRecentMessageState(\n                        state\n                    )) as State;\n\n                    for (const responseMessage of responseMessages) {\n                        if (\n                            responseMessage ===\n                            responseMessages[responseMessages.length - 1]\n                        ) {\n                            responseMessage.content.action = response.action;\n                        } else {\n                            responseMessage.content.action = \"CONTINUE\";\n                        }\n                        await this.runtime.messageManager.createMemory(\n                            responseMessage\n                        );\n                    }\n\n                    await this.runtime.processActions(\n                        message,\n                        responseMessages,\n                        state,\n                        callback\n                    );\n\n                    const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                    await this.runtime.cacheManager.set(\n                        `twitter/tweet_generation_${tweet.id}.txt`,\n                        responseInfo\n                    );\n                    await wait();\n                } catch (error) {\n                    elizaLogger.error(`Error sending response tweet: ${error}`);\n                }\n            }\n        }\n    }\n\n    async buildConversationThread(\n        tweet: Tweet,\n        maxReplies: number = 10\n    ): Promise<Tweet[]> {\n        const thread: Tweet[] = [];\n        const visited: Set<string> = new Set();\n\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\n            elizaLogger.log(\"Processing tweet:\", {\n                id: currentTweet.id,\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\n                depth: depth,\n            });\n\n            if (!currentTweet) {\n                elizaLogger.log(\"No current tweet found for thread building\");\n                return;\n            }\n\n            if (depth >= maxReplies) {\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\n                return;\n            }\n\n            // Handle memory storage\n            const memory = await this.runtime.messageManager.getMemoryById(\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\n            );\n            if (!memory) {\n                const roomId = stringToUuid(\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\n                );\n                const userId = stringToUuid(currentTweet.userId);\n\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    currentTweet.username,\n                    currentTweet.name,\n                    \"twitter\"\n                );\n\n                this.runtime.messageManager.createMemory({\n                    id: stringToUuid(\n                        currentTweet.id + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: currentTweet.text,\n                        source: \"twitter\",\n                        url: currentTweet.permanentUrl,\n                        inReplyTo: currentTweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  currentTweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    },\n                    createdAt: currentTweet.timestamp * 1000,\n                    roomId,\n                    userId:\n                        currentTweet.userId === this.twitterUserId\n                            ? this.runtime.agentId\n                            : stringToUuid(currentTweet.userId),\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            if (visited.has(currentTweet.id)) {\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\n                return;\n            }\n\n            visited.add(currentTweet.id);\n            thread.unshift(currentTweet);\n\n            elizaLogger.debug(\"Current thread state:\", {\n                length: thread.length,\n                currentDepth: depth,\n                tweetId: currentTweet.id,\n            });\n\n            if (currentTweet.inReplyToStatusId) {\n                elizaLogger.log(\n                    \"Fetching parent tweet:\",\n                    currentTweet.inReplyToStatusId\n                );\n                try {\n                    const parentTweet = await this.twitterClient.getTweet(\n                        currentTweet.inReplyToStatusId\n                    );\n\n                    if (parentTweet) {\n                        elizaLogger.log(\"Found parent tweet:\", {\n                            id: parentTweet.id,\n                            text: parentTweet.text?.slice(0, 50),\n                        });\n                        await processThread(parentTweet, depth + 1);\n                    } else {\n                        elizaLogger.log(\n                            \"No parent tweet found for:\",\n                            currentTweet.inReplyToStatusId\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\n                        tweetId: currentTweet.inReplyToStatusId,\n                        error,\n                    });\n                }\n            } else {\n                elizaLogger.log(\n                    \"Reached end of reply chain at:\",\n                    currentTweet.id\n                );\n            }\n        }\n\n        // Need to bind this context for the inner function\n        await processThread.bind(this)(tweet, 0);\n\n        elizaLogger.debug(\"Final thread built:\", {\n            totalTweets: thread.length,\n            tweetIds: thread.map((t) => ({\n                id: t.id,\n                text: t.text?.slice(0, 50),\n            })),\n        });\n\n        return thread;\n    }\n}","import { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@elizaos/core\";\nimport { Content, Memory, UUID } from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { Media } from \"@elizaos/core\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: Tweet,\n    client: ClientBase,\n    maxReplies: number = 10\n): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.userId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.username,\n                currentTweet.name,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.userId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.userId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweet = await client.twitterClient.getTweet(\n                    currentTweet.inReplyToStatusId\n                );\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\n    const isLongTweet = maxTweetLength > 280;\n\n    const tweetChunks = splitTweetContent(content.text, maxTweetLength);\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData: { data: Buffer; mediaType: string }[] | undefined;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await Promise.all(\n                content.attachments.map(async (attachment: Media) => {\n                    if (/^(http|https):\\/\\//.test(attachment.url)) {\n                        // Handle HTTP URLs\n                        const response = await fetch(attachment.url);\n                        if (!response.ok) {\n                            throw new Error(\n                                `Failed to fetch file: ${attachment.url}`\n                            );\n                        }\n                        const mediaBuffer = Buffer.from(\n                            await response.arrayBuffer()\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else if (fs.existsSync(attachment.url)) {\n                        // Handle local file paths\n                        const mediaBuffer = await fs.promises.readFile(\n                            path.resolve(attachment.url)\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else {\n                        throw new Error(\n                            `File not found: ${attachment.url}. Make sure the path is correct.`\n                        );\n                    }\n                })\n            );\n        }\n\n        const cleanChunk = deduplicateMentions(chunk.trim())\n\n        const result = await client.requestQueue.add(async () =>\n            isLongTweet\n                ? client.twitterClient.sendLongTweet(\n                      cleanChunk,\n                      previousTweetId,\n                      mediaData\n                  )\n                : client.twitterClient.sendTweet(\n                      cleanChunk,\n                      previousTweetId,\n                      mediaData\n                  )\n        );\n\n        const body = await result.json();\n        const tweetResult = isLongTweet\n            ? body?.data?.notetweet_create?.tweet_results?.result\n            : body?.data?.create_tweet?.tweet_results?.result;\n\n        // if we have a response\n        if (tweetResult) {\n            // Parse the response\n            const finalTweet: Tweet = {\n                id: tweetResult.rest_id,\n                text: tweetResult.legacy.full_text,\n                conversationId: tweetResult.legacy.conversation_id_str,\n                timestamp:\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\n                userId: tweetResult.legacy.user_id_str,\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n                hashtags: [],\n                mentions: [],\n                photos: [],\n                thread: [],\n                urls: [],\n                videos: [],\n            };\n            sentTweets.push(finalTweet);\n            previousTweetId = finalTweet.id;\n        } else {\n            elizaLogger.error(\"Error sending tweet chunk:\", {\n                chunk,\n                response: body,\n            });\n        }\n\n        // Wait a bit between tweets to avoid rate limiting issues\n        await wait(1000, 2000);\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction extractUrls(paragraph: string): {\n    textWithPlaceholders: string;\n    placeholderMap: Map<string, string>;\n} {\n    // replace https urls with placeholder\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const placeholderMap = new Map<string, string>();\n\n    let urlIndex = 0;\n    const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n        // twitter url would be considered as 23 characters\n        // <<URL_CONSIDERER_23_1>> is also 23 characters\n        const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n        placeholderMap.set(placeholder, match);\n        urlIndex++;\n        return placeholder;\n    });\n\n    return { textWithPlaceholders, placeholderMap };\n}\n\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n    // Split by periods, question marks and exclamation marks\n    // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n    const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            // Can't fit more, push currentChunk to results\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n\n            // If current sentence itself is less than or equal to maxLength\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Need to split sentence by spaces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining content\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n\nfunction deduplicateMentions(paragraph: string) {\n    // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ')\n\n  // Deduplicate mentions\n  mentions = [...new Set(mentions)];\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\n}\n\nfunction restoreUrls(\n    chunks: string[],\n    placeholderMap: Map<string, string>\n): string[] {\n    return chunks.map((chunk) => {\n        // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n        return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n            const original = placeholderMap.get(match);\n            return original || match; // Return placeholder if not found (theoretically won't happen)\n        });\n    });\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // 1) Extract URLs and replace with placeholders\n    const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n    // 2) Use first section's logic to split by sentences first, then do secondary split\n    const splittedChunks = splitSentencesAndWords(\n        textWithPlaceholders,\n        maxLength\n    );\n\n    // 3) Replace placeholders back to original URLs\n    const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n    return restoredChunks;\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    TemplateType,\n    UUID,\n    truncateToCompleteSentence,\n} from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { ClientBase } from \"./base.ts\";\nimport { postActionResponseFooter } from \"@elizaos/core\";\nimport { generateTweetActions } from \"@elizaos/core\";\nimport { IImageDescriptionService, ServiceType } from \"@elizaos/core\";\nimport { buildConversationThread } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment.ts\";\nimport {\n    Client,\n    Events,\n    GatewayIntentBits,\n    TextChannel,\n    Partials,\n} from \"discord.js\";\nimport { State } from \"@elizaos/core\";\nimport { ActionResponse } from \"@elizaos/core\";\n\nconst MAX_TIMELINES_TO_FETCH = 15;\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n    `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- ONLY engage with content that DIRECTLY relates to character's core interests\n- Direct mentions are priority IF they are on-topic\n- Skip ALL content that is:\n  - Off-topic or tangentially related\n  - From high-profile accounts unless explicitly relevant\n  - Generic/viral content without specific relevance\n  - Political/controversial unless central to character\n  - Promotional/marketing unless directly relevant\n\nActions (respond only with tags):\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\n[QUOTE] - Can add substantial domain expertise (9.5/10)\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\n    postActionResponseFooter;\n\ninterface PendingTweet {\n    cleanedContent: string;\n    roomId: UUID;\n    newTweetContent: string;\n    discordMessageId: string;\n    channelId: string;\n    timestamp: number;\n}\n\ntype PendingTweetApprovalStatus = \"PENDING\" | \"APPROVED\" | \"REJECTED\";\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing: boolean = false;\n    private lastProcessTime: number = 0;\n    private stopProcessingActions: boolean = false;\n    private isDryRun: boolean;\n    private discordClientForApproval: Client;\n    private approvalRequired: boolean = false;\n    private discordApprovalChannelId: string;\n    private approvalCheckInterval: number;\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n\n        // Log configuration on initialization\n        elizaLogger.log(\"Twitter Client Configuration:\");\n        elizaLogger.log(`- Username: ${this.twitterUsername}`);\n        elizaLogger.log(\n            `- Dry Run Mode: ${this.isDryRun ? \"enabled\" : \"disabled\"}`\n        );\n        elizaLogger.log(\n            `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`\n        );\n        elizaLogger.log(\n            `- Action Processing: ${this.client.twitterConfig.ENABLE_ACTION_PROCESSING ? \"enabled\" : \"disabled\"}`\n        );\n        elizaLogger.log(\n            `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`\n        );\n        elizaLogger.log(\n            `- Post Immediately: ${this.client.twitterConfig.POST_IMMEDIATELY ? \"enabled\" : \"disabled\"}`\n        );\n        elizaLogger.log(\n            `- Search Enabled: ${this.client.twitterConfig.TWITTER_SEARCH_ENABLE ? \"enabled\" : \"disabled\"}`\n        );\n\n        const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\n        if (targetUsers) {\n            elizaLogger.log(`- Target Users: ${targetUsers}`);\n        }\n\n        if (this.isDryRun) {\n            elizaLogger.log(\n                \"Twitter client initialized in dry run mode - no actual tweets should be posted\"\n            );\n        }\n\n        // Initialize Discord webhook\n        const approvalRequired: boolean =\n            this.runtime\n                .getSetting(\"TWITTER_APPROVAL_ENABLED\")\n                ?.toLocaleLowerCase() === \"true\";\n        if (approvalRequired) {\n            const discordToken = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\"\n            );\n            const approvalChannelId = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_CHANNEL_ID\"\n            );\n\n            const APPROVAL_CHECK_INTERVAL =\n                parseInt(\n                    this.runtime.getSetting(\"TWITTER_APPROVAL_CHECK_INTERVAL\")\n                ) || 5 * 60 * 1000; // 5 minutes\n\n            this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\n\n            if (!discordToken || !approvalChannelId) {\n                throw new Error(\n                    \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow\"\n                );\n            }\n\n            this.approvalRequired = true;\n            this.discordApprovalChannelId = approvalChannelId;\n\n            // Set up Discord client event handlers\n            this.setupDiscordClient();\n        }\n    }\n\n    private setupDiscordClient() {\n        this.discordClientForApproval = new Client({\n            intents: [\n                GatewayIntentBits.Guilds,\n                GatewayIntentBits.GuildMessages,\n                GatewayIntentBits.MessageContent,\n                GatewayIntentBits.GuildMessageReactions,\n            ],\n            partials: [Partials.Channel, Partials.Message, Partials.Reaction],\n        });\n        this.discordClientForApproval.once(\n            Events.ClientReady,\n            (readyClient) => {\n                elizaLogger.log(\n                    `Discord bot is ready as ${readyClient.user.tag}!`\n                );\n\n                // Generate invite link with required permissions\n                const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\n                // 274877991936 includes permissions for:\n                // - Send Messages\n                // - Read Messages/View Channels\n                // - Read Message History\n\n                elizaLogger.log(\n                    `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`\n                );\n            }\n        );\n        // Login to Discord\n        this.discordClientForApproval.login(\n            this.runtime.getSetting(\"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\")\n        );\n    }\n\n    async start() {\n        if (!this.client.profile) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            // Check for pending tweets first\n            if (this.approvalRequired) await this.handlePendingTweet();\n\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"twitter/\" + this.twitterUsername + \"/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;\n            const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewTweet();\n            }\n\n            setTimeout(() => {\n                generateNewTweetLoop(); // Set up next iteration\n            }, delay);\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        const processActionsLoop = async () => {\n            const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\n\n            while (!this.stopProcessingActions) {\n                try {\n                    const results = await this.processTweetActions();\n                    if (results) {\n                        elizaLogger.log(`Processed ${results.length} tweets`);\n                        elizaLogger.log(\n                            `Next action processing scheduled in ${actionInterval} minutes`\n                        );\n                        // Wait for the full interval before next processing\n                        await new Promise(\n                            (resolve) =>\n                                setTimeout(resolve, actionInterval * 60 * 1000) // now in minutes\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error in action processing loop:\",\n                        error\n                    );\n                    // Add exponential backoff on error\n                    await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n                }\n            }\n        };\n\n        if (this.client.twitterConfig.POST_IMMEDIATELY) {\n            await this.generateNewTweet();\n        }\n\n        // Only start tweet generation loop if not in dry run mode\n        generateNewTweetLoop();\n        elizaLogger.log(\"Tweet generation loop started\");\n\n        if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\n            processActionsLoop().catch((error) => {\n                elizaLogger.error(\n                    \"Fatal error in process actions loop:\",\n                    error\n                );\n            });\n        }\n\n        // Start the pending tweet check loop if enabled\n        if (this.approvalRequired) this.runPendingTweetCheckLoop();\n    }\n\n    private runPendingTweetCheckLoop() {\n        setInterval(async () => {\n            await this.handlePendingTweet();\n        }, this.approvalCheckInterval);\n    }\n\n    createTweetObject(\n        tweetResult: any,\n        client: any,\n        twitterUsername: string\n    ): Tweet {\n        return {\n            id: tweetResult.rest_id,\n            name: client.profile.screenName,\n            username: client.profile.username,\n            text: tweetResult.legacy.full_text,\n            conversationId: tweetResult.legacy.conversation_id_str,\n            createdAt: tweetResult.legacy.created_at,\n            timestamp: new Date(tweetResult.legacy.created_at).getTime(),\n            userId: client.profile.id,\n            inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n            permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n            hashtags: [],\n            mentions: [],\n            photos: [],\n            thread: [],\n            urls: [],\n            videos: [],\n        } as Tweet;\n    }\n\n    async processAndCacheTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        tweet: Tweet,\n        roomId: UUID,\n        newTweetContent: string\n    ) {\n        // Cache the last post details\n        await runtime.cacheManager.set(\n            `twitter/${client.profile.username}/lastPost`,\n            {\n                id: tweet.id,\n                timestamp: Date.now(),\n            }\n        );\n\n        // Cache the tweet\n        await client.cacheTweet(tweet);\n\n        // Log the posted tweet\n        elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n        // Ensure the room and participant exist\n        await runtime.ensureRoomExists(roomId);\n        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n        // Create a memory for the tweet\n        await runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + \"-\" + runtime.agentId),\n            userId: runtime.agentId,\n            agentId: runtime.agentId,\n            content: {\n                text: newTweetContent.trim(),\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n            },\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp,\n        });\n    }\n\n    async handleNoteTweet(\n        client: ClientBase,\n        content: string,\n        tweetId?: string\n    ) {\n        try {\n            const noteTweetResult = await client.requestQueue.add(\n                async () =>\n                    await client.twitterClient.sendNoteTweet(content, tweetId)\n            );\n\n            if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n                // Note Tweet failed due to authorization. Falling back to standard Tweet.\n                const truncateContent = truncateToCompleteSentence(\n                    content,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n                return await this.sendStandardTweet(\n                    client,\n                    truncateContent,\n                    tweetId\n                );\n            } else {\n                return noteTweetResult.data.notetweet_create.tweet_results\n                    .result;\n            }\n        } catch (error) {\n            throw new Error(`Note Tweet failed: ${error}`);\n        }\n    }\n\n    async sendStandardTweet(\n        client: ClientBase,\n        content: string,\n        tweetId?: string\n    ) {\n        try {\n            const standardTweetResult = await client.requestQueue.add(\n                async () =>\n                    await client.twitterClient.sendTweet(content, tweetId)\n            );\n            const body = await standardTweetResult.json();\n            if (!body?.data?.create_tweet?.tweet_results?.result) {\n                console.error(\"Error sending tweet; Bad response:\", body);\n                return;\n            }\n            return body.data.create_tweet.tweet_results.result;\n        } catch (error) {\n            elizaLogger.error(\"Error sending standard Tweet:\", error);\n            throw error;\n        }\n    }\n\n    async postTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        cleanedContent: string,\n        roomId: UUID,\n        newTweetContent: string,\n        twitterUsername: string\n    ) {\n        try {\n            elizaLogger.log(`Posting new tweet:\\n`);\n\n            let result;\n\n            if (cleanedContent.length > DEFAULT_MAX_TWEET_LENGTH) {\n                result = await this.handleNoteTweet(client, cleanedContent);\n            } else {\n                result = await this.sendStandardTweet(client, cleanedContent);\n            }\n\n            const tweet = this.createTweetObject(\n                result,\n                client,\n                twitterUsername\n            );\n\n            await this.processAndCacheTweet(\n                runtime,\n                client,\n                tweet,\n                roomId,\n                newTweetContent\n            );\n        } catch (error) {\n            elizaLogger.error(\"Error sending tweet:\", error);\n        }\n    }\n\n    /**\n     * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n     */\n    async generateNewTweet() {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n            const roomId = stringToUuid(\n                \"twitter_generate_room-\" + this.client.profile.username\n            );\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.client.profile.username,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const topics = this.runtime.character.topics.join(\", \");\n\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics || \"\",\n                        action: \"TWEET\",\n                    },\n                },\n                {\n                    twitterUserName: this.client.profile.username,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterPostTemplate ||\n                    twitterPostTemplate,\n            });\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const newTweetContent = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // First attempt to clean content\n            let cleanedContent = \"\";\n\n            // Try parsing as JSON first\n            try {\n                const parsedResponse = JSON.parse(newTweetContent);\n                if (parsedResponse.text) {\n                    cleanedContent = parsedResponse.text;\n                } else if (typeof parsedResponse === \"string\") {\n                    cleanedContent = parsedResponse;\n                }\n            } catch (error) {\n                error.linted = true; // make linter happy since catch needs a variable\n                // If not JSON, clean the raw content\n                cleanedContent = newTweetContent\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\n                    .replace(/\\\\n/g, \"\\n\\n\") // Unescape newlines, ensures double spaces\n                    .trim();\n            }\n\n            if (!cleanedContent) {\n                elizaLogger.error(\n                    \"Failed to extract valid content from response:\",\n                    {\n                        rawResponse: newTweetContent,\n                        attempted: \"JSON parsing\",\n                    }\n                );\n                return;\n            }\n\n            // Truncate the content to the maximum tweet length specified in the environment settings, ensuring the truncation respects sentence boundaries.\n            const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;\n            if (maxTweetLength) {\n                cleanedContent = truncateToCompleteSentence(\n                    cleanedContent,\n                    maxTweetLength\n                );\n            }\n\n            const removeQuotes = (str: string) =>\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n            const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, \"\\n\\n\"); //ensures double spaces\n\n            // Final cleaning\n            cleanedContent = removeQuotes(fixNewLines(cleanedContent));\n\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: would have posted tweet: ${cleanedContent}`\n                );\n                return;\n            }\n\n            try {\n                if (this.approvalRequired) {\n                    // Send for approval instead of posting directly\n                    elizaLogger.log(\n                        `Sending Tweet For Approval:\\n ${cleanedContent}`\n                    );\n                    await this.sendForApproval(\n                        cleanedContent,\n                        roomId,\n                        newTweetContent\n                    );\n                    elizaLogger.log(\"Tweet sent for approval\");\n                } else {\n                    elizaLogger.log(`Posting new tweet:\\n ${cleanedContent}`);\n                    this.postTweet(\n                        this.runtime,\n                        this.client,\n                        cleanedContent,\n                        roomId,\n                        newTweetContent,\n                        this.twitterUsername\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error sending tweet:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n    }\n\n    private async generateTweetContent(\n        tweetState: any,\n        options?: {\n            template?: TemplateType;\n            context?: string;\n        }\n    ): Promise<string> {\n        const context = composeContext({\n            state: tweetState,\n            template:\n                options?.template ||\n                this.runtime.character.templates?.twitterPostTemplate ||\n                twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL,\n        });\n        elizaLogger.debug(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = response\n            .replace(/```json\\s*/g, \"\") // Remove ```json\n            .replace(/```\\s*/g, \"\") // Remove any remaining ```\n            .replaceAll(/\\\\n/g, \"\\n\")\n            .trim();\n\n        // Try to parse as JSON first\n        try {\n            const jsonResponse = JSON.parse(cleanedResponse);\n            if (jsonResponse.text) {\n                return this.trimTweetLength(jsonResponse.text);\n            }\n            if (typeof jsonResponse === \"object\") {\n                const possibleContent =\n                    jsonResponse.content ||\n                    jsonResponse.message ||\n                    jsonResponse.response;\n                if (possibleContent) {\n                    return this.trimTweetLength(possibleContent);\n                }\n            }\n        } catch (error) {\n            error.linted = true; // make linter happy since catch needs a variable\n\n            // If JSON parsing fails, treat as plain text\n            elizaLogger.debug(\"Response is not JSON, treating as plain text\");\n        }\n\n        // If not JSON or no valid content found, clean the raw text\n        return this.trimTweetLength(cleanedResponse);\n    }\n\n    // Helper method to ensure tweet length compliance\n    private trimTweetLength(text: string, maxLength: number = 280): string {\n        if (text.length <= maxLength) return text;\n\n        // Try to cut at last sentence\n        const lastSentence = text.slice(0, maxLength).lastIndexOf(\".\");\n        if (lastSentence > 0) {\n            return text.slice(0, lastSentence + 1).trim();\n        }\n\n        // Fallback to word boundary\n        return (\n            text.slice(0, text.lastIndexOf(\" \", maxLength - 3)).trim() + \"...\"\n        );\n    }\n\n    /**\n     * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\n     * only simulates and logs actions without making API calls.\n     */\n    private async processTweetActions() {\n        if (this.isProcessing) {\n            elizaLogger.log(\"Already processing tweet actions, skipping\");\n            return null;\n        }\n\n        try {\n            this.isProcessing = true;\n            this.lastProcessTime = Date.now();\n\n            elizaLogger.log(\"Processing tweet actions\");\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.twitterUsername,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const timelines = await this.client.fetchTimelineForActions(\n                MAX_TIMELINES_TO_FETCH\n            );\n            const maxActionsProcessing =\n                this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\n            const processedTimelines = [];\n\n            for (const tweet of timelines) {\n                try {\n                    // Skip if we've already processed this tweet\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n                    if (memory) {\n                        elizaLogger.log(\n                            `Already processed tweet ID: ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const tweetState = await this.runtime.composeState(\n                        {\n                            userId: this.runtime.agentId,\n                            roomId,\n                            agentId: this.runtime.agentId,\n                            content: { text: \"\", action: \"\" },\n                        },\n                        {\n                            twitterUserName: this.twitterUsername,\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n                        }\n                    );\n\n                    const actionContext = composeContext({\n                        state: tweetState,\n                        template:\n                            this.runtime.character.templates\n                                ?.twitterActionTemplate ||\n                            twitterActionTemplate,\n                    });\n\n                    const actionResponse = await generateTweetActions({\n                        runtime: this.runtime,\n                        context: actionContext,\n                        modelClass: ModelClass.SMALL,\n                    });\n\n                    if (!actionResponse) {\n                        elizaLogger.log(\n                            `No valid actions generated for tweet ${tweet.id}`\n                        );\n                        continue;\n                    }\n                    processedTimelines.push({\n                        tweet: tweet,\n                        actionResponse: actionResponse,\n                        tweetState: tweetState,\n                        roomId: roomId,\n                    });\n                } catch (error) {\n                    elizaLogger.error(\n                        `Error processing tweet ${tweet.id}:`,\n                        error\n                    );\n                    continue;\n                }\n            }\n\n            const sortProcessedTimeline = (arr: typeof processedTimelines) => {\n                return arr.sort((a, b) => {\n                    // Count the number of true values in the actionResponse object\n                    const countTrue = (obj: typeof a.actionResponse) =>\n                        Object.values(obj).filter(Boolean).length;\n\n                    const countA = countTrue(a.actionResponse);\n                    const countB = countTrue(b.actionResponse);\n\n                    // Primary sort by number of true values\n                    if (countA !== countB) {\n                        return countB - countA;\n                    }\n\n                    // Secondary sort by the \"like\" property\n                    if (a.actionResponse.like !== b.actionResponse.like) {\n                        return a.actionResponse.like ? -1 : 1;\n                    }\n\n                    // Tertiary sort keeps the remaining objects with equal weight\n                    return 0;\n                });\n            };\n            // Sort the timeline based on the action decision score,\n            // then slice the results according to the environment variable to limit the number of actions per cycle.\n            const sortedTimelines = sortProcessedTimeline(\n                processedTimelines\n            ).slice(0, maxActionsProcessing);\n\n            return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\n        } catch (error) {\n            elizaLogger.error(\"Error in processTweetActions:\", error);\n            throw error;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Processes a list of timelines by executing the corresponding tweet actions.\n     * Each timeline includes the tweet, action response, tweet state, and room context.\n     * Results are returned for tracking completed actions.\n     *\n     * @param timelines - Array of objects containing tweet details, action responses, and state information.\n     * @returns A promise that resolves to an array of results with details of executed actions.\n     */\n    private async processTimelineActions(\n        timelines: {\n            tweet: Tweet;\n            actionResponse: ActionResponse;\n            tweetState: State;\n            roomId: UUID;\n        }[]\n    ): Promise<\n        {\n            tweetId: string;\n            actionResponse: ActionResponse;\n            executedActions: string[];\n        }[]\n    > {\n        const results = [];\n        for (const timeline of timelines) {\n            const { actionResponse, tweetState, roomId, tweet } = timeline;\n            try {\n                const executedActions: string[] = [];\n                // Execute actions\n                if (actionResponse.like) {\n                    if (this.isDryRun) {\n                        elizaLogger.info(\n                            `Dry run: would have liked tweet ${tweet.id}`\n                        );\n                        executedActions.push(\"like (dry run)\");\n                    } else {\n                        try {\n                            await this.client.twitterClient.likeTweet(tweet.id);\n                            executedActions.push(\"like\");\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error liking tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n                }\n\n                if (actionResponse.retweet) {\n                    if (this.isDryRun) {\n                        elizaLogger.info(\n                            `Dry run: would have retweeted tweet ${tweet.id}`\n                        );\n                        executedActions.push(\"retweet (dry run)\");\n                    } else {\n                        try {\n                            await this.client.twitterClient.retweet(tweet.id);\n                            executedActions.push(\"retweet\");\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error retweeting tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n                }\n\n                if (actionResponse.quote) {\n                    try {\n                        // Build conversation thread for context\n                        const thread = await buildConversationThread(\n                            tweet,\n                            this.client\n                        );\n                        const formattedConversation = thread\n                            .map(\n                                (t) =>\n                                    `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                            )\n                            .join(\"\\n\\n\");\n\n                        // Generate image descriptions if present\n                        const imageDescriptions = [];\n                        if (tweet.photos?.length > 0) {\n                            elizaLogger.log(\n                                \"Processing images in tweet for context\"\n                            );\n                            for (const photo of tweet.photos) {\n                                const description = await this.runtime\n                                    .getService<IImageDescriptionService>(\n                                        ServiceType.IMAGE_DESCRIPTION\n                                    )\n                                    .describeImage(photo.url);\n                                imageDescriptions.push(description);\n                            }\n                        }\n\n                        // Handle quoted tweet if present\n                        let quotedContent = \"\";\n                        if (tweet.quotedStatusId) {\n                            try {\n                                const quotedTweet =\n                                    await this.client.twitterClient.getTweet(\n                                        tweet.quotedStatusId\n                                    );\n                                if (quotedTweet) {\n                                    quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                                }\n                            } catch (error) {\n                                elizaLogger.error(\n                                    \"Error fetching quoted tweet:\",\n                                    error\n                                );\n                            }\n                        }\n\n                        // Compose rich state with all context\n                        const enrichedState = await this.runtime.composeState(\n                            {\n                                userId: this.runtime.agentId,\n                                roomId: stringToUuid(\n                                    tweet.conversationId +\n                                        \"-\" +\n                                        this.runtime.agentId\n                                ),\n                                agentId: this.runtime.agentId,\n                                content: {\n                                    text: tweet.text,\n                                    action: \"QUOTE\",\n                                },\n                            },\n                            {\n                                twitterUserName: this.twitterUsername,\n                                currentPost: `From @${tweet.username}: ${tweet.text}`,\n                                formattedConversation,\n                                imageContext:\n                                    imageDescriptions.length > 0\n                                        ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                                        : \"\",\n                                quotedContent,\n                            }\n                        );\n\n                        const quoteContent = await this.generateTweetContent(\n                            enrichedState,\n                            {\n                                template:\n                                    this.runtime.character.templates\n                                        ?.twitterMessageHandlerTemplate ||\n                                    twitterMessageHandlerTemplate,\n                            }\n                        );\n\n                        if (!quoteContent) {\n                            elizaLogger.error(\n                                \"Failed to generate valid quote tweet content\"\n                            );\n                            return;\n                        }\n\n                        elizaLogger.log(\n                            \"Generated quote tweet content:\",\n                            quoteContent\n                        );\n                        // Check for dry run mode\n                        if (this.isDryRun) {\n                            elizaLogger.info(\n                                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent}\".`\n                            );\n                            executedActions.push(\"quote (dry run)\");\n                        } else {\n                            // Send the tweet through request queue\n                            const result = await this.client.requestQueue.add(\n                                async () =>\n                                    await this.client.twitterClient.sendQuoteTweet(\n                                        quoteContent,\n                                        tweet.id\n                                    )\n                            );\n\n                            const body = await result.json();\n\n                            if (\n                                body?.data?.create_tweet?.tweet_results?.result\n                            ) {\n                                elizaLogger.log(\n                                    \"Successfully posted quote tweet\"\n                                );\n                                executedActions.push(\"quote\");\n\n                                // Cache generation context for debugging\n                                await this.runtime.cacheManager.set(\n                                    `twitter/quote_generation_${tweet.id}.txt`,\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\n                                );\n                            } else {\n                                elizaLogger.error(\n                                    \"Quote tweet creation failed:\",\n                                    body\n                                );\n                            }\n                        }\n                    } catch (error) {\n                        elizaLogger.error(\n                            \"Error in quote tweet generation:\",\n                            error\n                        );\n                    }\n                }\n\n                if (actionResponse.reply) {\n                    try {\n                        await this.handleTextOnlyReply(\n                            tweet,\n                            tweetState,\n                            executedActions\n                        );\n                    } catch (error) {\n                        elizaLogger.error(\n                            `Error replying to tweet ${tweet.id}:`,\n                            error\n                        );\n                    }\n                }\n\n                // Add these checks before creating memory\n                await this.runtime.ensureRoomExists(roomId);\n                await this.runtime.ensureUserExists(\n                    stringToUuid(tweet.userId),\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                if (!this.isDryRun) {\n                    // Then create the memory\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId: stringToUuid(tweet.userId),\n                        content: {\n                            text: tweet.text,\n                            url: tweet.permanentUrl,\n                            source: \"twitter\",\n                            action: executedActions.join(\",\"),\n                        },\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n                }\n\n                results.push({\n                    tweetId: tweet.id,\n                    actionResponse: actionResponse,\n                    executedActions,\n                });\n            } catch (error) {\n                elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n                continue;\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Handles text-only replies to tweets. If isDryRun is true, only logs what would\n     * have been replied without making API calls.\n     */\n    private async handleTextOnlyReply(\n        tweet: Tweet,\n        tweetState: any,\n        executedActions: string[]\n    ) {\n        try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n                .map(\n                    (t) =>\n                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                )\n                .join(\"\\n\\n\");\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n                elizaLogger.log(\"Processing images in tweet for context\");\n                for (const photo of tweet.photos) {\n                    const description = await this.runtime\n                        .getService<IImageDescriptionService>(\n                            ServiceType.IMAGE_DESCRIPTION\n                        )\n                        .describeImage(photo.url);\n                    imageDescriptions.push(description);\n                }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = \"\";\n            if (tweet.quotedStatusId) {\n                try {\n                    const quotedTweet =\n                        await this.client.twitterClient.getTweet(\n                            tweet.quotedStatusId\n                        );\n                    if (quotedTweet) {\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error fetching quoted tweet:\", error);\n                }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: { text: tweet.text, action: \"\" },\n                },\n                {\n                    twitterUserName: this.twitterUsername,\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                    formattedConversation,\n                    imageContext:\n                        imageDescriptions.length > 0\n                            ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                            : \"\",\n                    quotedContent,\n                }\n            );\n\n            // Generate and clean the reply content\n            const replyText = await this.generateTweetContent(enrichedState, {\n                template:\n                    this.runtime.character.templates\n                        ?.twitterMessageHandlerTemplate ||\n                    twitterMessageHandlerTemplate,\n            });\n\n            if (!replyText) {\n                elizaLogger.error(\"Failed to generate valid reply content\");\n                return;\n            }\n\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: reply to tweet ${tweet.id} would have been: ${replyText}`\n                );\n                executedActions.push(\"reply (dry run)\");\n                return;\n            }\n\n            elizaLogger.debug(\"Final reply text to be sent:\", replyText);\n\n            let result;\n\n            if (replyText.length > DEFAULT_MAX_TWEET_LENGTH) {\n                result = await this.handleNoteTweet(\n                    this.client,\n                    replyText,\n                    tweet.id\n                );\n            } else {\n                result = await this.sendStandardTweet(\n                    this.client,\n                    replyText,\n                    tweet.id\n                );\n            }\n\n            if (result) {\n                elizaLogger.log(\"Successfully posted reply tweet\");\n                executedActions.push(\"reply\");\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                    `twitter/reply_generation_${tweet.id}.txt`,\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\n                );\n            } else {\n                elizaLogger.error(\"Tweet reply creation failed\");\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\n        }\n    }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n\n    private async sendForApproval(\n        cleanedContent: string,\n        roomId: UUID,\n        newTweetContent: string\n    ): Promise<string | null> {\n        try {\n            const embed = {\n                title: \"New Tweet Pending Approval\",\n                description: cleanedContent,\n                fields: [\n                    {\n                        name: \"Character\",\n                        value: this.client.profile.username,\n                        inline: true,\n                    },\n                    {\n                        name: \"Length\",\n                        value: cleanedContent.length.toString(),\n                        inline: true,\n                    },\n                ],\n                footer: {\n                    text: \"Reply with '' to post or '' to discard, This will automatically expire and remove after 24 hours if no response received\",\n                },\n                timestamp: new Date().toISOString(),\n            };\n\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            if (!channel || !(channel instanceof TextChannel)) {\n                throw new Error(\"Invalid approval channel\");\n            }\n\n            const message = await channel.send({ embeds: [embed] });\n\n            // Store the pending tweet\n            const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n            const currentPendingTweets =\n                (await this.runtime.cacheManager.get<PendingTweet[]>(\n                    pendingTweetsKey\n                )) || [];\n            // Add new pending tweet\n            currentPendingTweets.push({\n                cleanedContent,\n                roomId,\n                newTweetContent,\n                discordMessageId: message.id,\n                channelId: this.discordApprovalChannelId,\n                timestamp: Date.now(),\n            });\n\n            // Store updated array\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                currentPendingTweets\n            );\n\n            return message.id;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error Sending Twitter Post Approval Request:\",\n                error\n            );\n            return null;\n        }\n    }\n\n    private async checkApprovalStatus(\n        discordMessageId: string\n    ): Promise<PendingTweetApprovalStatus> {\n        try {\n            // Fetch message and its replies from Discord\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            elizaLogger.log(`channel ${JSON.stringify(channel)}`);\n\n            if (!(channel instanceof TextChannel)) {\n                elizaLogger.error(\"Invalid approval channel\");\n                return \"PENDING\";\n            }\n\n            // Fetch the original message and its replies\n            const message = await channel.messages.fetch(discordMessageId);\n\n            // Look for thumbs up reaction ('')\n            const thumbsUpReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"\"\n            );\n\n            // Look for reject reaction ('')\n            const rejectReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"\"\n            );\n\n            // Check if the reaction exists and has reactions\n            if (rejectReaction) {\n                const count = rejectReaction.count;\n                if (count > 0) {\n                    return \"REJECTED\";\n                }\n            }\n\n            // Check if the reaction exists and has reactions\n            if (thumbsUpReaction) {\n                // You might want to check for specific users who can approve\n                // For now, we'll return true if anyone used thumbs up\n                const count = thumbsUpReaction.count;\n                if (count > 0) {\n                    return \"APPROVED\";\n                }\n            }\n\n            return \"PENDING\";\n        } catch (error) {\n            elizaLogger.error(\"Error checking approval status:\", error);\n            return \"PENDING\";\n        }\n    }\n\n    private async cleanupPendingTweet(discordMessageId: string) {\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const currentPendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        // Remove the specific tweet\n        const updatedPendingTweets = currentPendingTweets.filter(\n            (tweet) => tweet.discordMessageId !== discordMessageId\n        );\n\n        if (updatedPendingTweets.length === 0) {\n            await this.runtime.cacheManager.delete(pendingTweetsKey);\n        } else {\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                updatedPendingTweets\n            );\n        }\n    }\n\n    private async handlePendingTweet() {\n        elizaLogger.log(\"Checking Pending Tweets...\");\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const pendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        for (const pendingTweet of pendingTweets) {\n            // Check if tweet is older than 24 hours\n            const isExpired =\n                Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\n\n            if (isExpired) {\n                elizaLogger.log(\"Pending tweet expired, cleaning up\");\n\n                // Notify on Discord about expiration\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"This tweet approval request has expired (24h timeout).\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending expiration notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                return;\n            }\n\n            // Check approval status\n            elizaLogger.log(\"Checking approval status...\");\n            const approvalStatus: PendingTweetApprovalStatus =\n                await this.checkApprovalStatus(pendingTweet.discordMessageId);\n\n            if (approvalStatus === \"APPROVED\") {\n                elizaLogger.log(\"Tweet Approved, Posting\");\n                await this.postTweet(\n                    this.runtime,\n                    this.client,\n                    pendingTweet.cleanedContent,\n                    pendingTweet.roomId,\n                    pendingTweet.newTweetContent,\n                    this.twitterUsername\n                );\n\n                // Notify on Discord about posting\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been posted successfully! \"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending post notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n            } else if (approvalStatus === \"REJECTED\") {\n                elizaLogger.log(\"Tweet Rejected, Cleaning Up\");\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                // Notify about Rejection of Tweet\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been rejected! \"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending rejection notification:\",\n                        error\n                    );\n                }\n            }\n        }\n    }\n}\n","import { SearchMode } from \"agent-twitter-client\";\nimport { composeContext, elizaLogger } from \"@elizaos/core\";\nimport { generateMessageResponse, generateText } from \"@elizaos/core\";\nimport { messageCompletionFooter } from \"@elizaos/core\";\nimport {\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    IImageDescriptionService,\n    ModelClass,\n    ServiceType,\n    State,\n} from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nconst twitterSearchTemplate =\n    `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private respondedTweets: Set<string> = new Set();\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n    }\n\n    async start() {\n        this.engageWithSearchTermsLoop();\n    }\n\n    private engageWithSearchTermsLoop() {\n        this.engageWithSearchTerms().then();\n        const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;\n        elizaLogger.log(\n            `Next twitter search scheduled in ${randomMinutes} minutes`\n        );\n        setTimeout(\n            () => this.engageWithSearchTermsLoop(),\n            randomMinutes * 60 * 1000\n        );\n    }\n\n    private async engageWithSearchTerms() {\n        elizaLogger.log(\"Engaging with search terms\");\n        try {\n            const searchTerm = [...this.runtime.character.topics][\n                Math.floor(Math.random() * this.runtime.character.topics.length)\n            ];\n\n            elizaLogger.log(\"Fetching search tweets\");\n            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n            await new Promise((resolve) => setTimeout(resolve, 5000));\n            const recentTweets = await this.client.fetchSearchTweets(\n                searchTerm,\n                20,\n                SearchMode.Top\n            );\n            elizaLogger.log(\"Search tweets fetched\");\n\n            const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n            await this.client.cacheTimeline(homeTimeline);\n\n            const formattedHomeTimeline =\n                `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n                homeTimeline\n                    .map((tweet) => {\n                        return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\\nText: ${tweet.text}\\n---\\n`;\n                    })\n                    .join(\"\\n\");\n\n            // randomly slice .tweets down to 20\n            const slicedTweets = recentTweets.tweets\n                .sort(() => Math.random() - 0.5)\n                .slice(0, 20);\n\n            if (slicedTweets.length === 0) {\n                elizaLogger.log(\n                    \"No valid tweets found for the search term\",\n                    searchTerm\n                );\n                return;\n            }\n\n            const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n      .filter((tweet) => {\n          // ignore tweets where any of the thread tweets contain a tweet by the bot\n          const thread = tweet.thread;\n          const botTweet = thread.find(\n              (t) => t.username === this.twitterUsername\n          );\n          return !botTweet;\n      })\n      .map(\n          (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `\n      )\n      .join(\"\\n\")}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n            const mostInterestingTweetResponse = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const tweetId = mostInterestingTweetResponse.trim();\n            const selectedTweet = slicedTweets.find(\n                (tweet) =>\n                    tweet.id.toString().includes(tweetId) ||\n                    tweetId.includes(tweet.id.toString())\n            );\n\n            if (!selectedTweet) {\n                elizaLogger.warn(\"No matching tweet found for the selected ID\");\n                elizaLogger.log(\"Selected tweet ID:\", tweetId);\n                return;\n            }\n\n            elizaLogger.log(\"Selected tweet to reply to:\", selectedTweet?.text);\n\n            if (selectedTweet.username === this.twitterUsername) {\n                elizaLogger.log(\"Skipping tweet from bot itself\");\n                return;\n            }\n\n            const conversationId = selectedTweet.conversationId;\n            const roomId = stringToUuid(\n                conversationId + \"-\" + this.runtime.agentId\n            );\n\n            const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n            await this.runtime.ensureConnection(\n                userIdUUID,\n                roomId,\n                selectedTweet.username,\n                selectedTweet.name,\n                \"twitter\"\n            );\n\n            // crawl additional conversation tweets, if there are any\n            await buildConversationThread(selectedTweet, this.client);\n\n            const message = {\n                id: stringToUuid(selectedTweet.id + \"-\" + this.runtime.agentId),\n                agentId: this.runtime.agentId,\n                content: {\n                    text: selectedTweet.text,\n                    url: selectedTweet.permanentUrl,\n                    inReplyTo: selectedTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              selectedTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                // Timestamps are in seconds, but we need them in milliseconds\n                createdAt: selectedTweet.timestamp * 1000,\n            };\n\n            if (!message.content.text) {\n                elizaLogger.warn(\"Returning: No response text found\");\n                return;\n            }\n\n            // Fetch replies and retweets\n            const replies = selectedTweet.thread;\n            const replyContext = replies\n                .filter((reply) => reply.username !== this.twitterUsername)\n                .map((reply) => `@${reply.username}: ${reply.text}`)\n                .join(\"\\n\");\n\n            let tweetBackground = \"\";\n            if (selectedTweet.isRetweet) {\n                const originalTweet = await this.client.requestQueue.add(() =>\n                    this.client.twitterClient.getTweet(selectedTweet.id)\n                );\n                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n            }\n\n            // Generate image descriptions using GPT-4 vision API\n            const imageDescriptions = [];\n            for (const photo of selectedTweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptions.push(description);\n            }\n\n            let state = await this.runtime.composeState(message, {\n                twitterClient: this.client.twitterClient,\n                twitterUserName: this.twitterUsername,\n                timeline: formattedHomeTimeline,\n                tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(\", \")}\\n` : \"\"}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(\", \")}\\n` : \"\"}\n  `,\n            });\n\n            await this.client.saveRequestMessage(message, state as State);\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterSearchTemplate ||\n                    twitterSearchTemplate,\n            });\n\n            const responseContent = await generateMessageResponse({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            responseContent.inReplyTo = message.id;\n\n            const response = responseContent;\n\n            if (!response.text) {\n                elizaLogger.warn(\"Returning: No response text found\");\n                return;\n            }\n\n            elizaLogger.log(\n                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`\n            );\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.twitterUsername,\n                        tweetId\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(responseContent);\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                for (const responseMessage of responseMessages) {\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage,\n                        false\n                    );\n                }\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                await this.runtime.evaluate(message, state);\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                this.respondedTweets.add(selectedTweet.id);\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${selectedTweet.id}.txt`,\n                    responseInfo\n                );\n\n                await wait();\n            } catch (error) {\n                console.error(`Error sending response post: ${error}`);\n            }\n        } catch (error) {\n            console.error(\"Error engaging with search terms:\", error);\n        }\n    }\n}\n","import {\n    elizaLogger,\n    IAgentRuntime,\n    composeContext,\n    generateText,\n    ModelClass,\n    ServiceType,\n    ITranscriptionService,\n} from \"@elizaos/core\";\nimport { ClientBase } from \"./base\";\nimport {\n    Scraper,\n    Space,\n    SpaceConfig,\n    RecordToDiskPlugin,\n    IdleMonitorPlugin,\n    SpeakerRequest,\n} from \"agent-twitter-client\";\nimport { SttTtsPlugin } from \"./plugins/SttTtsSpacesPlugin.ts\";\n\ninterface SpaceDecisionOptions {\n    maxSpeakers?: number;\n    topics?: string[];\n    typicalDurationMinutes?: number;\n    idleKickTimeoutMs?: number;\n    minIntervalBetweenSpacesMinutes?: number;\n    businessHoursOnly?: boolean;\n    randomChance?: number;\n    enableIdleMonitor?: boolean;\n    enableSttTts?: boolean;\n    enableRecording?: boolean;\n    voiceId?: string;\n    sttLanguage?: string;\n    gptModel?: string;\n    systemPrompt?: string;\n    speakerMaxDurationMs?: number;\n}\n\ninterface CurrentSpeakerState {\n    userId: string;\n    sessionUUID: string;\n    username: string;\n    startTime: number;\n}\n\n/**\n * Generate short filler text via GPT\n */\nasync function generateFiller(\n    runtime: IAgentRuntime,\n    fillerType: string\n): Promise<string> {\n    try {\n        const context = composeContext({\n            state: { fillerType },\n            template: `\n# INSTRUCTIONS:\nYou are generating a short filler message for a Twitter Space. The filler type is \"{{fillerType}}\".\nKeep it brief, friendly, and relevant. No more than two sentences.\nOnly return the text, no additional formatting.\n\n---\n`,\n        });\n        const output = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        return output.trim();\n    } catch (err) {\n        elizaLogger.error(\"[generateFiller] Error generating filler:\", err);\n        return \"\";\n    }\n}\n\n/**\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\n */\nasync function speakFiller(\n    runtime: IAgentRuntime,\n    sttTtsPlugin: SttTtsPlugin | undefined,\n    fillerType: string,\n    sleepAfterMs = 3000\n): Promise<void> {\n    if (!sttTtsPlugin) return;\n    const text = await generateFiller(runtime, fillerType);\n    if (!text) return;\n\n    elizaLogger.log(`[Space] Filler (${fillerType}) => ${text}`);\n    await sttTtsPlugin.speakText(text);\n\n    if (sleepAfterMs > 0) {\n        await new Promise((res) => setTimeout(res, sleepAfterMs));\n    }\n}\n\n/**\n * Generate topic suggestions via GPT if no topics are configured\n */\nasync function generateTopicsIfEmpty(\n    runtime: IAgentRuntime\n): Promise<string[]> {\n    try {\n        const context = composeContext({\n            state: {},\n            template: `\n# INSTRUCTIONS:\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\nReturn them as a comma-separated list, no additional formatting or numbering.\n\nExample:\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\n---\n`,\n        });\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        const topics = response\n            .split(\",\")\n            .map((t) => t.trim())\n            .filter(Boolean);\n        return topics.length ? topics : [\"Random Tech Chat\", \"AI Thoughts\"];\n    } catch (err) {\n        elizaLogger.error(\"[generateTopicsIfEmpty] GPT error =>\", err);\n        return [\"Random Tech Chat\", \"AI Thoughts\"];\n    }\n}\n\n/**\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\n */\nexport class TwitterSpaceClient {\n    private client: ClientBase;\n    private scraper: Scraper;\n    private isSpaceRunning = false;\n    private currentSpace?: Space;\n    private spaceId?: string;\n    private startedAt?: number;\n    private checkInterval?: NodeJS.Timeout;\n    private lastSpaceEndedAt?: number;\n    private sttTtsPlugin?: SttTtsPlugin;\n\n    /**\n     * We now store an array of active speakers, not just 1\n     */\n    private activeSpeakers: CurrentSpeakerState[] = [];\n    private speakerQueue: SpeakerRequest[] = [];\n\n    private decisionOptions: SpaceDecisionOptions;\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.scraper = client.twitterClient;\n\n        const charSpaces = runtime.character.twitterSpaces || {};\n        this.decisionOptions = {\n            maxSpeakers: charSpaces.maxSpeakers ?? 1,\n            topics: charSpaces.topics ?? [],\n            typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\n            idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\n            minIntervalBetweenSpacesMinutes:\n                charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\n            businessHoursOnly: charSpaces.businessHoursOnly ?? false,\n            randomChance: charSpaces.randomChance ?? 0.3,\n            enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\n            enableSttTts: charSpaces.enableSttTts !== false,\n            enableRecording: charSpaces.enableRecording !== false,\n            voiceId:\n                charSpaces.voiceId ||\n                runtime.character.settings.voice.model ||\n                \"Xb7hH8MSUJpSbSDYk0k2\",\n            sttLanguage: charSpaces.sttLanguage || \"en\",\n            gptModel: charSpaces.gptModel,\n            systemPrompt: charSpaces.systemPrompt,\n            speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\n        };\n    }\n\n    /**\n     * Periodic check to launch or manage space\n     */\n    public async startPeriodicSpaceCheck() {\n        elizaLogger.log(\"[Space] Starting periodic check routine...\");\n\n        // For instance:\n        const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running\n        const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running\n\n        const routine = async () => {\n            try {\n                if (!this.isSpaceRunning) {\n                    // Space not running => check if we should launch\n                    const launch = await this.shouldLaunchSpace();\n                    if (launch) {\n                        const config = await this.generateSpaceConfig();\n                        await this.startSpace(config);\n                    }\n                    // Plan next iteration with a slower pace\n                    this.checkInterval = setTimeout(\n                        routine,\n                        this.isSpaceRunning\n                            ? intervalMsWhenRunning\n                            : intervalMsWhenIdle\n                    );\n                } else {\n                    // Space is running => manage it more frequently\n                    await this.manageCurrentSpace();\n                    // Plan next iteration with a faster pace\n                    this.checkInterval = setTimeout(\n                        routine,\n                        intervalMsWhenRunning\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"[Space] Error in routine =>\", error);\n                // In case of error, still schedule next iteration\n                this.checkInterval = setTimeout(routine, intervalMsWhenIdle);\n            }\n        };\n\n        routine();\n    }\n\n    stopPeriodicCheck() {\n        if (this.checkInterval) {\n            clearTimeout(this.checkInterval);\n            this.checkInterval = undefined;\n        }\n    }\n\n    private async shouldLaunchSpace(): Promise<boolean> {\n        // Random chance\n        const r = Math.random();\n        if (r > (this.decisionOptions.randomChance ?? 0.3)) {\n            elizaLogger.log(\"[Space] Random check => skip launching\");\n            return false;\n        }\n        // Business hours\n        if (this.decisionOptions.businessHoursOnly) {\n            const hour = new Date().getUTCHours();\n            if (hour < 9 || hour >= 17) {\n                elizaLogger.log(\"[Space] Out of business hours => skip\");\n                return false;\n            }\n        }\n        // Interval\n        const now = Date.now();\n        if (this.lastSpaceEndedAt) {\n            const minIntervalMs =\n                (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) *\n                60_000;\n            if (now - this.lastSpaceEndedAt < minIntervalMs) {\n                elizaLogger.log(\"[Space] Too soon since last space => skip\");\n                return false;\n            }\n        }\n\n        elizaLogger.log(\"[Space] Deciding to launch a new Space...\");\n        return true;\n    }\n\n    private async generateSpaceConfig(): Promise<SpaceConfig> {\n        if (\n            !this.decisionOptions.topics ||\n            this.decisionOptions.topics.length === 0\n        ) {\n            const newTopics = await generateTopicsIfEmpty(this.client.runtime);\n            this.decisionOptions.topics = newTopics;\n        }\n\n        let chosenTopic = \"Random Tech Chat\";\n        if (\n            this.decisionOptions.topics &&\n            this.decisionOptions.topics.length > 0\n        ) {\n            chosenTopic =\n                this.decisionOptions.topics[\n                    Math.floor(\n                        Math.random() * this.decisionOptions.topics.length\n                    )\n                ];\n        }\n\n        return {\n            mode: \"INTERACTIVE\",\n            title: chosenTopic,\n            description: `Discussion about ${chosenTopic}`,\n            languages: [\"en\"],\n        };\n    }\n\n    public async startSpace(config: SpaceConfig) {\n        elizaLogger.log(\"[Space] Starting a new Twitter Space...\");\n\n        try {\n            this.currentSpace = new Space(this.scraper);\n            this.isSpaceRunning = false;\n            this.spaceId = undefined;\n            this.startedAt = Date.now();\n\n            // Reset states\n            this.activeSpeakers = [];\n            this.speakerQueue = [];\n\n            // Retrieve keys\n            const openAiKey = process.env.OPENAI_API_KEY || \"\";\n            const elevenLabsKey = process.env.ELEVENLABS_XI_API_KEY || \"\";\n\n            // Plugins\n            if (this.decisionOptions.enableRecording) {\n                elizaLogger.log(\"[Space] Using RecordToDiskPlugin\");\n                this.currentSpace.use(new RecordToDiskPlugin());\n            }\n\n            if (this.decisionOptions.enableSttTts) {\n                elizaLogger.log(\"[Space] Using SttTtsPlugin\");\n                const sttTts = new SttTtsPlugin();\n                this.sttTtsPlugin = sttTts;\n                this.currentSpace.use(sttTts, {\n                    openAiApiKey: openAiKey,\n                    elevenLabsApiKey: elevenLabsKey,\n                    voiceId: this.decisionOptions.voiceId,\n                    gptModel: this.decisionOptions.gptModel,\n                    systemPrompt: this.decisionOptions.systemPrompt,\n                    sttLanguage: this.decisionOptions.sttLanguage,\n                    transcriptionService:\n                        this.client.runtime.getService<ITranscriptionService>(\n                            ServiceType.TRANSCRIPTION\n                        ),\n                });\n            }\n\n            if (this.decisionOptions.enableIdleMonitor) {\n                elizaLogger.log(\"[Space] Using IdleMonitorPlugin\");\n                this.currentSpace.use(\n                    new IdleMonitorPlugin(\n                        this.decisionOptions.idleKickTimeoutMs ?? 60_000,\n                        10_000\n                    )\n                );\n            }\n\n            const broadcastInfo = await this.currentSpace.initialize(config);\n            this.spaceId = broadcastInfo.room_id;\n            this.isSpaceRunning = true;\n            await this.scraper.sendTweet(\n                broadcastInfo.share_url.replace(\"broadcasts\", \"spaces\")\n            );\n\n            const spaceUrl = broadcastInfo.share_url.replace(\n                \"broadcasts\",\n                \"spaces\"\n            );\n            elizaLogger.log(`[Space] Space started => ${spaceUrl}`);\n\n            // Greet\n            await speakFiller(\n                this.client.runtime,\n                this.sttTtsPlugin,\n                \"WELCOME\"\n            );\n\n            // Events\n            this.currentSpace.on(\"occupancyUpdate\", (update) => {\n                elizaLogger.log(\n                    `[Space] Occupancy => ${update.occupancy} participant(s).`\n                );\n            });\n\n            this.currentSpace.on(\n                \"speakerRequest\",\n                async (req: SpeakerRequest) => {\n                    elizaLogger.log(\n                        `[Space] Speaker request from @${req.username} (${req.userId}).`\n                    );\n                    await this.handleSpeakerRequest(req);\n                }\n            );\n\n            this.currentSpace.on(\"idleTimeout\", async (info) => {\n                elizaLogger.log(\n                    `[Space] idleTimeout => no audio for ${info.idleMs} ms.`\n                );\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"IDLE_ENDING\"\n                );\n                await this.stopSpace();\n            });\n\n            process.on(\"SIGINT\", async () => {\n                elizaLogger.log(\"[Space] SIGINT => stopping space\");\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"CLOSING\"\n                );\n                await this.stopSpace();\n                process.exit(0);\n            });\n        } catch (error) {\n            elizaLogger.error(\"[Space] Error launching Space =>\", error);\n            this.isSpaceRunning = false;\n            throw error;\n        }\n    }\n\n    /**\n     * Periodic management: check durations, remove extras, maybe accept new from queue\n     */\n    private async manageCurrentSpace() {\n        if (!this.spaceId || !this.currentSpace) return;\n        try {\n            const audioSpace = await this.scraper.getAudioSpaceById(\n                this.spaceId\n            );\n            const { participants } = audioSpace;\n            const numSpeakers = participants.speakers?.length || 0;\n            const totalListeners = participants.listeners?.length || 0;\n\n            // 1) Remove any speaker who exceeded speakerMaxDurationMs\n            const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;\n            const now = Date.now();\n\n            for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\n                const speaker = this.activeSpeakers[i];\n                const elapsed = now - speaker.startTime;\n                if (elapsed > maxDur) {\n                    elizaLogger.log(\n                        `[Space] Speaker @${speaker.username} exceeded max duration => removing`\n                    );\n                    await this.removeSpeaker(speaker.userId);\n                    this.activeSpeakers.splice(i, 1);\n\n                    // Possibly speak a short \"SPEAKER_LEFT\" filler\n                    await speakFiller(\n                        this.client.runtime,\n                        this.sttTtsPlugin,\n                        \"SPEAKER_LEFT\"\n                    );\n                }\n            }\n\n            // 2) If we have capacity for new speakers from the queue, accept them\n            await this.acceptSpeakersFromQueueIfNeeded();\n\n            // 3) If somehow more than maxSpeakers are active, remove the extras\n            if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\n                elizaLogger.log(\n                    \"[Space] More than maxSpeakers => removing extras...\"\n                );\n                await this.kickExtraSpeakers(participants.speakers);\n            }\n\n            // 4) Possibly stop the space if empty or time exceeded\n            const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\n            if (\n                elapsedMinutes >\n                    (this.decisionOptions.typicalDurationMinutes ?? 30) ||\n                (numSpeakers === 0 &&\n                    totalListeners === 0 &&\n                    elapsedMinutes > 5)\n            ) {\n                elizaLogger.log(\n                    \"[Space] Condition met => stopping the Space...\"\n                );\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"CLOSING\",\n                    4000\n                );\n                await this.stopSpace();\n            }\n        } catch (error) {\n            elizaLogger.error(\"[Space] Error in manageCurrentSpace =>\", error);\n        }\n    }\n\n    /**\n     * If we have available slots, accept new speakers from the queue\n     */\n    private async acceptSpeakersFromQueueIfNeeded() {\n        // while queue not empty and activeSpeakers < maxSpeakers, accept next\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\n        while (\n            this.speakerQueue.length > 0 &&\n            this.activeSpeakers.length < ms\n        ) {\n            const nextReq = this.speakerQueue.shift();\n            if (nextReq) {\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"PRE_ACCEPT\"\n                );\n                await this.acceptSpeaker(nextReq);\n            }\n        }\n    }\n\n    private async handleSpeakerRequest(req: SpeakerRequest) {\n        if (!this.spaceId || !this.currentSpace) return;\n\n        const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n        const janusSpeakers = audioSpace?.participants?.speakers || [];\n\n        // If we haven't reached maxSpeakers, accept immediately\n        if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {\n            elizaLogger.log(`[Space] Accepting speaker @${req.username} now`);\n            await speakFiller(\n                this.client.runtime,\n                this.sttTtsPlugin,\n                \"PRE_ACCEPT\"\n            );\n            await this.acceptSpeaker(req);\n        } else {\n            elizaLogger.log(\n                `[Space] Adding speaker @${req.username} to the queue`\n            );\n            this.speakerQueue.push(req);\n        }\n    }\n\n    private async acceptSpeaker(req: SpeakerRequest) {\n        if (!this.currentSpace) return;\n        try {\n            await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);\n            this.activeSpeakers.push({\n                userId: req.userId,\n                sessionUUID: req.sessionUUID,\n                username: req.username,\n                startTime: Date.now(),\n            });\n            elizaLogger.log(`[Space] Speaker @${req.username} is now live`);\n        } catch (err) {\n            elizaLogger.error(\n                `[Space] Error approving speaker @${req.username}:`,\n                err\n            );\n        }\n    }\n\n    private async removeSpeaker(userId: string) {\n        if (!this.currentSpace) return;\n        try {\n            await this.currentSpace.removeSpeaker(userId);\n            elizaLogger.log(`[Space] Removed speaker userId=${userId}`);\n        } catch (error) {\n            elizaLogger.error(\n                `[Space] Error removing speaker userId=${userId} =>`,\n                error\n            );\n        }\n    }\n\n    /**\n     * If more than maxSpeakers are found, remove extras\n     * Also update activeSpeakers array\n     */\n    private async kickExtraSpeakers(speakers: any[]) {\n        if (!this.currentSpace) return;\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\n\n        // sort by who joined first if needed, or just slice\n        const extras = speakers.slice(ms);\n        for (const sp of extras) {\n            elizaLogger.log(\n                `[Space] Removing extra speaker => userId=${sp.user_id}`\n            );\n            await this.removeSpeaker(sp.user_id);\n\n            // remove from activeSpeakers array\n            const idx = this.activeSpeakers.findIndex(\n                (s) => s.userId === sp.user_id\n            );\n            if (idx !== -1) {\n                this.activeSpeakers.splice(idx, 1);\n            }\n        }\n    }\n\n    public async stopSpace() {\n        if (!this.currentSpace || !this.isSpaceRunning) return;\n        try {\n            elizaLogger.log(\"[Space] Stopping the current Space...\");\n            await this.currentSpace.stop();\n        } catch (err) {\n            elizaLogger.error(\"[Space] Error stopping Space =>\", err);\n        } finally {\n            this.isSpaceRunning = false;\n            this.spaceId = undefined;\n            this.currentSpace = undefined;\n            this.startedAt = undefined;\n            this.lastSpaceEndedAt = Date.now();\n            this.activeSpeakers = [];\n            this.speakerQueue = [];\n        }\n    }\n}\n","// src/plugins/SttTtsPlugin.ts\n\nimport { spawn } from \"child_process\";\nimport { ITranscriptionService, elizaLogger } from \"@elizaos/core\";\nimport { Space, JanusClient, AudioDataWithUser } from \"agent-twitter-client\";\nimport { Plugin } from \"@elizaos/core\";\n\ninterface PluginConfig {\n    openAiApiKey?: string; // for STT & ChatGPT\n    elevenLabsApiKey?: string; // for TTS\n    sttLanguage?: string; // e.g. \"en\" for Whisper\n    gptModel?: string; // e.g. \"gpt-3.5-turbo\"\n    silenceThreshold?: number; // amplitude threshold for ignoring silence\n    voiceId?: string; // specify which ElevenLabs voice to use\n    elevenLabsModel?: string; // e.g. \"eleven_monolingual_v1\"\n    systemPrompt?: string; // ex. \"You are a helpful AI assistant\"\n    chatContext?: Array<{\n        role: \"system\" | \"user\" | \"assistant\";\n        content: string;\n    }>;\n    transcriptionService: ITranscriptionService;\n}\n\n/**\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\n * Approach:\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\n */\nexport class SttTtsPlugin implements Plugin {\n    name = \"SttTtsPlugin\";\n    description = \"Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\";\n\n    private space?: Space;\n    private janus?: JanusClient;\n\n    private openAiApiKey?: string;\n    private elevenLabsApiKey?: string;\n\n    private gptModel = \"gpt-3.5-turbo\";\n    private voiceId = \"21m00Tcm4TlvDq8ikWAM\";\n    private elevenLabsModel = \"eleven_monolingual_v1\";\n    private systemPrompt = \"You are a helpful AI assistant.\";\n    private chatContext: Array<{\n        role: \"system\" | \"user\" | \"assistant\";\n        content: string;\n    }> = [];\n\n    private transcriptionService: ITranscriptionService;\n\n    /**\n     * userId => arrayOfChunks (PCM Int16)\n     */\n    private pcmBuffers = new Map<string, Int16Array[]>();\n\n    /**\n     * Track mute states: userId => boolean (true=unmuted)\n     */\n    private speakerUnmuted = new Map<string, boolean>();\n\n    /**\n     * For ignoring near-silence frames (if amplitude < threshold)\n     */\n    private silenceThreshold = 50;\n\n    // TTS queue for sequentially speaking\n    private ttsQueue: string[] = [];\n    private isSpeaking = false;\n\n    onAttach(_space: Space) {\n        elizaLogger.log(\"[SttTtsPlugin] onAttach => space was attached\");\n    }\n\n    init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n        elizaLogger.log(\n            \"[SttTtsPlugin] init => Space fully ready. Subscribing to events.\"\n        );\n\n        this.space = params.space;\n        this.janus = (this.space as any)?.janusClient as\n            | JanusClient\n            | undefined;\n\n        const config = params.pluginConfig as PluginConfig;\n        this.openAiApiKey = config?.openAiApiKey;\n        this.elevenLabsApiKey = config?.elevenLabsApiKey;\n        this.transcriptionService = config.transcriptionService;\n        if (config?.gptModel) this.gptModel = config.gptModel;\n        if (typeof config?.silenceThreshold === \"number\") {\n            this.silenceThreshold = config.silenceThreshold;\n        }\n        if (config?.voiceId) {\n            this.voiceId = config.voiceId;\n        }\n        if (config?.elevenLabsModel) {\n            this.elevenLabsModel = config.elevenLabsModel;\n        }\n        if (config?.systemPrompt) {\n            this.systemPrompt = config.systemPrompt;\n        }\n        if (config?.chatContext) {\n            this.chatContext = config.chatContext;\n        }\n        elizaLogger.log(\"[SttTtsPlugin] Plugin config =>\", config);\n\n        // Listen for mute events\n        this.space.on(\n            \"muteStateChanged\",\n            (evt: { userId: string; muted: boolean }) => {\n                elizaLogger.log(\n                    \"[SttTtsPlugin] Speaker muteStateChanged =>\",\n                    evt\n                );\n                if (evt.muted) {\n                    this.handleMute(evt.userId).catch((err) =>\n                        elizaLogger.error(\n                            \"[SttTtsPlugin] handleMute error =>\",\n                            err\n                        )\n                    );\n                } else {\n                    this.speakerUnmuted.set(evt.userId, true);\n                    if (!this.pcmBuffers.has(evt.userId)) {\n                        this.pcmBuffers.set(evt.userId, []);\n                    }\n                }\n            }\n        );\n    }\n\n    /**\n     * Called whenever we receive PCM from a speaker\n     */\n    onAudioData(data: AudioDataWithUser): void {\n        if (!this.speakerUnmuted.get(data.userId)) return;\n\n        let maxVal = 0;\n        for (let i = 0; i < data.samples.length; i++) {\n            const val = Math.abs(data.samples[i]);\n            if (val > maxVal) maxVal = val;\n        }\n        if (maxVal < this.silenceThreshold) {\n            return;\n        }\n\n        let arr = this.pcmBuffers.get(data.userId);\n        if (!arr) {\n            arr = [];\n            this.pcmBuffers.set(data.userId, arr);\n        }\n        arr.push(data.samples);\n    }\n\n    // /src/sttTtsPlugin.ts\n    private async convertPcmToWavInMemory(\n        pcmData: Int16Array,\n        sampleRate: number\n    ): Promise<ArrayBuffer> {\n        // number of channels\n        const numChannels = 1;\n        // byte rate = (sampleRate * numChannels * bitsPerSample/8)\n        const byteRate = sampleRate * numChannels * 2;\n        const blockAlign = numChannels * 2;\n        // data chunk size = pcmData.length * (bitsPerSample/8)\n        const dataSize = pcmData.length * 2;\n\n        // WAV header is 44 bytes\n        const buffer = new ArrayBuffer(44 + dataSize);\n        const view = new DataView(buffer);\n\n        // RIFF chunk descriptor\n        this.writeString(view, 0, \"RIFF\");\n        view.setUint32(4, 36 + dataSize, true); // file size - 8\n        this.writeString(view, 8, \"WAVE\");\n\n        // fmt sub-chunk\n        this.writeString(view, 12, \"fmt \");\n        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n        view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\n        view.setUint16(22, numChannels, true); // NumChannels\n        view.setUint32(24, sampleRate, true); // SampleRate\n        view.setUint32(28, byteRate, true); // ByteRate\n        view.setUint16(32, blockAlign, true); // BlockAlign\n        view.setUint16(34, 16, true); // BitsPerSample (16)\n\n        // data sub-chunk\n        this.writeString(view, 36, \"data\");\n        view.setUint32(40, dataSize, true);\n\n        // Write PCM samples\n        let offset = 44;\n        for (let i = 0; i < pcmData.length; i++, offset += 2) {\n            view.setInt16(offset, pcmData[i], true);\n        }\n\n        return buffer;\n    }\n\n    private writeString(view: DataView, offset: number, text: string) {\n        for (let i = 0; i < text.length; i++) {\n            view.setUint8(offset + i, text.charCodeAt(i));\n        }\n    }\n\n    /**\n     * On speaker mute => flush STT => GPT => TTS => push to Janus\n     */\n    private async handleMute(userId: string): Promise<void> {\n        this.speakerUnmuted.set(userId, false);\n        const chunks = this.pcmBuffers.get(userId) || [];\n        this.pcmBuffers.set(userId, []);\n\n        if (!chunks.length) {\n            elizaLogger.warn(\n                \"[SttTtsPlugin] No audio chunks for user =>\",\n                userId\n            );\n            return;\n        }\n        elizaLogger.log(\n            `[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`\n        );\n\n        const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\n        const merged = new Int16Array(totalLen);\n        let offset = 0;\n        for (const c of chunks) {\n            merged.set(c, offset);\n            offset += c.length;\n        }\n\n        // Convert PCM to WAV for STT\n        const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);\n\n        // Whisper STT\n        const sttText = await this.transcriptionService.transcribe(wavBuffer);\n\n        if (!sttText || !sttText.trim()) {\n            elizaLogger.warn(\n                \"[SttTtsPlugin] No speech recognized for user =>\",\n                userId\n            );\n            return;\n        }\n        elizaLogger.log(\n            `[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`\n        );\n\n        // GPT answer\n        const replyText = await this.askChatGPT(sttText);\n        elizaLogger.log(\n            `[SttTtsPlugin] GPT => user=${userId}, reply=\"${replyText}\"`\n        );\n\n        // Use the standard speak method with queue\n        await this.speakText(replyText);\n    }\n\n    /**\n     * Public method to queue a TTS request\n     */\n    public async speakText(text: string): Promise<void> {\n        this.ttsQueue.push(text);\n        if (!this.isSpeaking) {\n            this.isSpeaking = true;\n            this.processTtsQueue().catch((err) => {\n                elizaLogger.error(\n                    \"[SttTtsPlugin] processTtsQueue error =>\",\n                    err\n                );\n            });\n        }\n    }\n\n    /**\n     * Process TTS requests one by one\n     */\n    private async processTtsQueue(): Promise<void> {\n        while (this.ttsQueue.length > 0) {\n            const text = this.ttsQueue.shift();\n            if (!text) continue;\n\n            try {\n                const ttsAudio = await this.elevenLabsTts(text);\n                const pcm = await this.convertMp3ToPcm(ttsAudio, 48000);\n                await this.streamToJanus(pcm, 48000);\n            } catch (err) {\n                elizaLogger.error(\"[SttTtsPlugin] TTS streaming error =>\", err);\n            }\n        }\n        this.isSpeaking = false;\n    }\n\n    /**\n     * Simple ChatGPT call\n     */\n    private async askChatGPT(userText: string): Promise<string> {\n        if (!this.openAiApiKey) {\n            throw new Error(\"[SttTtsPlugin] No OpenAI API key for ChatGPT\");\n        }\n        const url = \"https://api.openai.com/v1/chat/completions\";\n        const messages = [\n            { role: \"system\", content: this.systemPrompt },\n            ...this.chatContext,\n            { role: \"user\", content: userText },\n        ];\n\n        const resp = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${this.openAiApiKey}`,\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                model: this.gptModel,\n                messages,\n            }),\n        });\n\n        if (!resp.ok) {\n            const errText = await resp.text();\n            throw new Error(\n                `[SttTtsPlugin] ChatGPT error => ${resp.status} ${errText}`\n            );\n        }\n\n        const json = await resp.json();\n        const reply = json.choices?.[0]?.message?.content || \"\";\n        this.chatContext.push({ role: \"user\", content: userText });\n        this.chatContext.push({ role: \"assistant\", content: reply });\n        return reply.trim();\n    }\n\n    /**\n     * ElevenLabs TTS => returns MP3 Buffer\n     */\n    private async elevenLabsTts(text: string): Promise<Buffer> {\n        if (!this.elevenLabsApiKey) {\n            throw new Error(\"[SttTtsPlugin] No ElevenLabs API key\");\n        }\n        const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;\n        const resp = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"xi-api-key\": this.elevenLabsApiKey,\n            },\n            body: JSON.stringify({\n                text,\n                model_id: this.elevenLabsModel,\n                voice_settings: { stability: 0.4, similarity_boost: 0.8 },\n            }),\n        });\n        if (!resp.ok) {\n            const errText = await resp.text();\n            throw new Error(\n                `[SttTtsPlugin] ElevenLabs TTS error => ${resp.status} ${errText}`\n            );\n        }\n        const arrayBuf = await resp.arrayBuffer();\n        return Buffer.from(arrayBuf);\n    }\n\n    /**\n     * Convert MP3 => PCM via ffmpeg\n     */\n    private convertMp3ToPcm(\n        mp3Buf: Buffer,\n        outRate: number\n    ): Promise<Int16Array> {\n        return new Promise((resolve, reject) => {\n            const ff = spawn(\"ffmpeg\", [\n                \"-i\",\n                \"pipe:0\",\n                \"-f\",\n                \"s16le\",\n                \"-ar\",\n                outRate.toString(),\n                \"-ac\",\n                \"1\",\n                \"pipe:1\",\n            ]);\n            let raw = Buffer.alloc(0);\n\n            ff.stdout.on(\"data\", (chunk: Buffer) => {\n                raw = Buffer.concat([raw, chunk]);\n            });\n            ff.stderr.on(\"data\", () => {\n                // ignoring ffmpeg logs\n            });\n            ff.on(\"close\", (code) => {\n                if (code !== 0) {\n                    reject(new Error(`ffmpeg error code=${code}`));\n                    return;\n                }\n                const samples = new Int16Array(\n                    raw.buffer,\n                    raw.byteOffset,\n                    raw.byteLength / 2\n                );\n                resolve(samples);\n            });\n\n            ff.stdin.write(mp3Buf);\n            ff.stdin.end();\n        });\n    }\n\n    /**\n     * Push PCM back to Janus in small frames\n     * We'll do 10ms @48k => 960 samples per frame\n     */\n    private async streamToJanus(\n        samples: Int16Array,\n        sampleRate: number\n    ): Promise<void> {\n        // TODO: Check if better than 480 fixed\n        const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz\n\n        for (\n            let offset = 0;\n            offset + FRAME_SIZE <= samples.length;\n            offset += FRAME_SIZE\n        ) {\n            const frame = new Int16Array(FRAME_SIZE);\n            frame.set(samples.subarray(offset, offset + FRAME_SIZE));\n            this.janus?.pushLocalAudio(frame, sampleRate, 1);\n\n            // Short pause so we don't overload\n            await new Promise((r) => setTimeout(r, 10));\n        }\n    }\n\n    public setSystemPrompt(prompt: string) {\n        this.systemPrompt = prompt;\n        elizaLogger.log(\"[SttTtsPlugin] setSystemPrompt =>\", prompt);\n    }\n\n    /**\n     * Change the GPT model at runtime (e.g. \"gpt-4\", \"gpt-3.5-turbo\", etc.).\n     */\n    public setGptModel(model: string) {\n        this.gptModel = model;\n        elizaLogger.log(\"[SttTtsPlugin] setGptModel =>\", model);\n    }\n\n    /**\n     * Add a message (system, user or assistant) to the chat context.\n     * E.g. to store conversation history or inject a persona.\n     */\n    public addMessage(role: \"system\" | \"user\" | \"assistant\", content: string) {\n        this.chatContext.push({ role, content });\n        elizaLogger.log(\n            `[SttTtsPlugin] addMessage => role=${role}, content=${content}`\n        );\n    }\n\n    /**\n     * Clear the chat context if needed.\n     */\n    public clearChatContext() {\n        this.chatContext = [];\n        elizaLogger.log(\"[SttTtsPlugin] clearChatContext => done\");\n    }\n\n    cleanup(): void {\n        elizaLogger.log(\"[SttTtsPlugin] cleanup => releasing resources\");\n        this.pcmBuffers.clear();\n        this.speakerUnmuted.clear();\n        this.ttsQueue = [];\n        this.isSpeaking = false;\n    }\n}\n"],"mappings":"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","names":["elizaLogger","existingMemories","existingMemoryIds","tweetsToSave","profile","ActionTimelineType","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","ServiceType","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","ModelClass","ServiceType","SearchMode","composeContext","elizaLogger","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","elizaLogger","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger","composeContext","generateText","ModelClass","ServiceType","elizaLogger","composeContext","generateText","ModelClass","elizaLogger","ServiceType","elizaLogger"]}